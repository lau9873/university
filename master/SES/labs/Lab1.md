# Lab 1 - Low-level security

We started by inspecting the code of the examples provided in the SARD test suite, analyzing the vulnerabilities and the
corresponding fixes.  
Afterwards, we picked a few examples to analyze in more detail using the tools explained in the lab.

## [Example 169 - Stack-overflow in loop ](https://github.com/hpacheco/ses/blob/main/c/SARD-testsuite-100/000/149/169/stack_overflow_loop-bad.c)

The first example is a stack overflow due to an incorrect loop index.  
The vulnerable code is the following:

```c
unsigned i;
char bStr[10];

for (i = 1; i <= 10; ++i)
    bStr[i] = (char)i + 'a';						/* FLAW */
```

In this case, the programming mistake is using a 1-based index instead of a 0-based index.  
This causes the loop to write one more byte than the buffer size, causing a stack overflow (CWE-121: Stack-based Buffer
Overflow).  
The correct
code ([example 170](https://github.com/hpacheco/ses/blob/main/c/SARD-testsuite-101/000/149/170/stack_overflow_loop-good.c))
would be:

```c
for (i = 0; i < 10; ++i)
    bStr[i] = (char)i + 'a';
```

To test this vulnerability, we took into account two aspects.  
First, we are dealing with a memory access violation.  
Second, the bug is always present, regardless of user input.  
Therefore, we decided to use two sets of tools to test this vulnerability: dynamic memory analysis (Valgrind,
AddressSanitizer) and static program analysis (scan-build, IKOS, Frama-C, Infer).

### Compiling and running the code

We started by compiling the code to check whether it would crash.

```sh
gcc -o stack_overflow_loop-bad stack_overflow_loop-bad.c
./stack_overflow_loop-bad
```

```
*** stack smashing detected ***: terminated
[1]    221052 IOT instruction (core dumped)  ./stack_overflow_loop-bad
```

The program crashes due to the protection mechanism against stack smashing.  
In order to properly test the vulnerability, we need to disable the protection mechanism.

```sh
gcc -fno-stack-protector -o stack_overflow_loop-bad stack_overflow_loop-bad.c
./stack_overflow_loop-bad
```

```
bcdefghij
``` 

This time, the program does not crash.  
However, the output is probably not what the original programmer intended.

### Dynamic memory analysis

#### Valgrind

We used Valgrind to check for memory errors during runtime.

```sh
valgrind --leak-check=full ./stack_overflow_loop-bad
```

```
...
==221960== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

Valgrind does not detect any memory errors.  
This is probably because the program does not allocate any memory and Valgrind's scanning techniques work by
intercepting malloc and free calls.

#### AddressSanitizer

Next, we used AddressSanitizer to check for memory errors during runtime.

```sh
gcc -fsanitize=address -o stack_overflow_loop-bad stack_overflow_loop-bad.c
./stack_overflow_loop-bad
```

```
=================================================================
==13==ERROR: AddressSanitizer: stack-buffer-overflow ...
...
  This frame has 1 object(s):
    [32, 42) 'bStr' (line 19) <== Memory access at offset 42 overflows this variable
...
SUMMARY: AddressSanitizer: stack-buffer-overflow (/app/stack_overflow_loop-bad+0x401236) in main
```

AddressSanitizer detects a stack buffer overflow, warning us where the overflow occurs.

### Static program analysis

#### scan-build

We used scan-build to check for errors during compilation.

```sh
scan-build gcc -o stack_overflow_loop-bad stack_overflow_loop-bad.c
```

```
....
scan-build: No bugs found.
```

No memory errors were detected.

#### IKOS

We used IKOS to check for errors during compilation.

```sh
ikos stack_overflow_loop-bad.c
```

```
...
# Results
stack_overflow_loop-bad.c: In function 'main':
stack_overflow_loop-bad.c:22:11: warning: possible buffer overflow, accessing index between 1 and 10 of local variable 'bStr' of 10 elements
                bStr[i] = (char)i + 'a';                                                /* FLAW */
                        ^
```

As expected, IKOS statically detected a buffer overflow.

##### Frama-C

We used Frama-C to check for errors during compilation.

```sh
frama-c -eva stack_overflow_loop-bad.c
```

```
...
[eva:summary] ====== ANALYSIS SUMMARY ======
  ----------------------------------------------------------------------------
  1 alarm generated by the analysis:
       1 access out of bounds index
  ----------------------------------------------------------------------------
```

As expected, Frama-C also detected the buffer overflow.

##### Cppcheck

We used Cppcheck to check for errors during compilation.

```sh
cppcheck --enable=all stack_overflow_loop-bad.c
```

```
Checking stack_overflow_loop-bad.c ...
stack_overflow_loop-bad.c:22:7: error: Array 'bStr[10]' accessed at index 10, which is out of bounds. [arrayIndexOutOfBounds]
  bStr[i] = (char)i + 'a';      /* FLAW */
      ^
stack_overflow_loop-bad.c:21:16: note: Assuming that condition 'i<=10' is not redundant
 for (i = 1; i <= 10; ++i)
               ^
stack_overflow_loop-bad.c:22:7: note: Array index out of bounds
  bStr[i] = (char)i + 'a';      /* FLAW */
      ^
```

In this case, Cppcheck detected the buffer overflow.

##### Infer

We used Infer to check for errors during compilation.

```sh
infer run -- gcc -o stack_overflow_loop-bad stack_overflow_loop-bad.c
```

```
stack_overflow_loop-bad.c:25: error: Uninitialized Value
  The value read from bStr[_] was never initialized.
  23. 
  24.   for (i = 1; i < 10; ++i)
  25.           printf("%c", bStr[i]);
        ^
  26. 
  27.   return 0;
```

Surprisingly, Infer detected an uninitialized value instead of a buffer overflow.  
The error report is wrong, as the value is initialized in the loop.  
Nevertheless, when running the corrected code, Infer does not report any error.

```sh
infer run -- gcc -o stack_overflow_loop-good stack_overflow_loop-good.c
```

```
Capturing in make/cc mode...
Found 1 source file to analyze in /app/c/SARD-testsuite-101/000/149/170/infer-out
1/1 [################################################################################] 100% 55.772ms

  No issues found  

```

We believe that Infer mistakenly detected an uninitialized value because of the overflow.  
In any case, the error would have alerted us to the fact that the code was not correct.

### Security vulnerability scanners

Finally, we used security vulnerability scanners to check for errors.

#### Flawfinder

We used Flawfinder to check for errors during compilation.

```sh
flawfinder stack_overflow_loop-bad.c
```

```
./stack_overflow_loop-bad.c:19:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.

```

Flawfinder did not detect any concrete errors.  
However, it warned about the use of a statically-sized array,   
It also suggested to perform bounds checking - which is the main oversight in this example.

## [Example 221 - Use-after-free](https://github.com/hpacheco/ses/blob/main/c/SARD-testsuite-100/000/149/221/use_after_free_scope-bad.c)

The second example is a use-after-free vulnerability.  
The vulnerable code is the following:

```c
void doSomething(char *str)
{
	str[0] = 'S';
}


int main(int argc, char *argv[])
{
	char *str = (char *)NULL;
	if ((str = (char *)malloc(256*sizeof(char))) != NULL)
	{
		strcpy(str, "Falut!");
		doSomething(str);
		printf("%s\n", str);
		free(str);	
				
		doSomething(str);							/* FLAW */
	}
	return 0;
}
```

The programmer's error is that the pointer `str` is used after it has been freed (CWE-416: Use After Free).  
The correct code is the following:

```c
void doSomething(char *str)
{
	if (!str)
		return;									/* FIX */
	str[0] = 'S';
}


int main(int argc, char *argv[])
{
	char *str = (char *)NULL;
	if ((str = (char *)malloc(256*sizeof(char))) != NULL)
	{
		strcpy(str, "Falut!");
		doSomething(str);
		printf("%s\n", str);
		free(str);
		str = NULL;
		
		doSomething(str);
	}
	return 0;
}
```

The correct version overwrites the dangling pointer with `NULL` after freeing it.  
This way, the pointer is not used after it has been freed and the program does not crash because the
function `doSomething` checks if the pointer is `NULL` before using it.

### Tool selection

Given the nature of the vulnerability, we felt that static analysis and memory error checkers would once again be the
most appropriate tools to use.  
Therefore, we used Valgrind, AddressSanitizer, IKOS, Frama-C, Cppcheck, Infer, and Flawfinder.

### Compiling and running the code

We compiled and ran the vulnerable code with the following commands:

```sh
gcc -o use_after_free_scope-bad use_after_free_scope-bad.c
./use_after_free_scope-bad
```

```
Falut!
```

The program seems to work as expected.

### Memory error checkers

#### Valgrind

When running the vulnerable code with Valgrind, we get the following output:

```sh
valgrind ./use_after_free_scope-bad
```

```
==250796== Invalid write of size 1
==250796==    at 0x109165: doSomething (in c/SARD-testsuite-100/000/149/221/use_after_free_scope-bad)
==250796==    by 0x1091D7: main (in c/SARD-testsuite-100/000/149/221/use_after_free_scope-bad)
==250796==  Address 0x4a5e040 is 0 bytes inside a block of size 256 free'd
==250796==    at 0x484426F: free (vg_replace_malloc.c:884)
==250796==    by 0x1091CB: main (in c/SARD-testsuite-100/000/149/221/use_after_free_scope-bad)
==250796==  Block was alloc'd at
==250796==    at 0x4841888: malloc (vg_replace_malloc.c:393)
==250796==    by 0x10918B: main (in c/SARD-testsuite-100/000/149/221/use_after_free_scope-bad)
```

Valgrind detected a use-after-free vulnerability.  
It shows that the pointer `str` is used to write 1 byte at address `0x4a5e040` after it has been freed in line 19.

#### AddressSanitizer

When running the vulnerable code with AddressSanitizer, we get the following output:

```sh
gcc -fsanitize=address -o use_after_free_scope-bad use_after_free_scope-bad.c
./use_after_free_scope-bad
```

```
=================================================================
==29==ERROR: AddressSanitizer: heap-use-after-free on address 0x611000000040 at pc 0x0000004011e6 bp 0x7cfad00b6ba0 sp
0x7cfad00b6b98
WRITE of size 1 at 0x611000000040 thread T0
#0 0x4011e5 in doSomething (/app/use_after_free_scope-bad+0x4011e5)
#1 0x401261 in main (/app/use_after_free_scope-bad+0x401261)
#2 0x6c4cf9bd7d09 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x23d09)
#3 0x4010e9 in _start (/app/use_after_free_scope-bad+0x4010e9)
```

AddressSanitizer also detected the use-after-free vulnerability.

### Static analysis

#### IKOS

```sh
ikos use_after_free_scope-bad.c
```

```
The program is definitely UNSAFE

# Results
use_after_free_scope-bad.c: In function 'doSomething':
use_after_free_scope-bad.c:19:9: error: use after free, pointer 'str' points to dynamic memory allocated at 'main:26:21'
        str[0] = 'S';
```

#### Frama-C

```sh
frama-c use_after_free_scope-bad.c
```

```
  1 alarm generated by the analysis:
       1 escaping address
  1 of them is a sure alarm (invalid status).
```

As we can see, Frama-C detected the use-after-free vulnerability.

## Smack

We started by running smack without any options on the vulnerable code.

```sh
    smack use_after_free_scope-bad.c
```

```
SMACK program verifier version 2.8.0
SMACK found no errors with unroll bound 1.
``` 

Then, we adjusted the flags to enable the memory safety checks.

```sh
    smack --check=memory-safety use_after_free_scope-bad.c
```

```
...
SMACK found an error: invalid pointer dereference.
```

#### Cppcheck

```sh
cppcheck --enable=all use_after_free_scope-bad.c
```

```
Checking use_after_free_scope-bad.c ...
```

Cppcheck did not detect any vulnerabilities, and we did not find any specific flags to enable memory safety checks.

#### Infer

```sh
infer run -- gcc -o use_after_free_scope-bad use_after_free_scope-bad.c
```

```
Capturing in make/cc mode...
Found 1 source file to analyze in /app/infer-out
1/1 [################################################################################] 100% 43.447ms
```

Infer did not detect any vulnerabilities, and we did not find any specific flags to customize the analysis.

### Security vulnerability scanners

#### Flawfinder

```sh
flawfinder use_after_free_scope-bad.c
```

```
FINAL RESULTS:

use_after_free_scope-bad.c:28:  [2] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused). Risk is low because the source is a constant string.
```

Flawfinder did not detect any vulnerabilities.  
However, it warns about the use of `strcpy` which is a known security vulnerability, even though the risk is low in this
case.

## Summary

These two vulnerabilities allowed us to experiment with multiple tools and techniques.  
We saw how important it is to use multiple tools to detect vulnerabilities, and how each tool has its own strengths and
weaknesses.  
More than that, we understood the need to use the correct options for each tool to get the best results, such as
enabling specific checks and unrolling loops.